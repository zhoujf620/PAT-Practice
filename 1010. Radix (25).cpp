// 1010. Radix (25)

// Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true?  The answer is "yes", if 6 is a decimal number and 110 is a binary number.

// Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given.

// Input Specification:

// Each input file contains one test case. Each case occupies a line which contains 4 positive integers:<br/>
// N1 N2 tag radix<br/>
// Here N1 and N2 each has no more than 10 digits.  A digit is less than its radix and is chosen from the set {0-9, a-z} where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35.  The last number "radix" is the radix of N1 if "tag" is 1, or of N2 if "tag" is 2. 

// Output Specification:

// For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true.  If the equation is impossible, print "Impossible".  If the solution is not unique, output the smallest possible radix.

// Sample Input 1:
// 6 110 1 10

// Sample Output 1:
// 2

// Sample Input 2:
// 1 ab 1 2

// Sample Output 2:
// Impossible


#include <iostream>
#include <algorithm>
#include<math.h>
using namespace std;

long long convert(string n, int radix) {
    long long sum = 0;
    int index = 0, temp = 0;
    for (auto it = n.rbegin(); it != n.rend(); it++) {
        temp = isdigit(*it) ? *it - '0' : *it - 'a' + 10;
        sum += temp * pow(radix, index++);
    }
    return sum;
}

long long find_radix(string n, long long num) {
    char it = *max_element(n.begin(), n.end());
    long long low = (isdigit(it) ? it - '0': it - 'a' + 10) + 1;
    long long high = max(num, low);

    while (low <= high) {
        long long mid = (low + high) / 2;
        long long t = convert(n, mid);
        if (t < 0 || t > num) high = mid - 1;
        else if (t == num) return mid;
        else low = mid + 1;
    }
    return -1;
}

int main() {
    string N1, N2;
    int tag = 0, radix = 0, result_radix;
    cin >> N1 >> N2 >> tag >> radix;

    result_radix = tag == 1 ? find_radix(N2, convert(N1, radix)) : find_radix(N1, convert(N2, radix));

    if (result_radix != -1) {
        printf("%d", result_radix);
    } else {
        printf("Impossible");
    }   
    return 0;
}